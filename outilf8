#!/usr/bin/perl
# -*- encoding: utf-8 -*-

use strict;
use warnings;
use charnames ':full';
use subs qw/conversion recherche utf8_to_ucs4 ucs4_to_utf8 normalise_lg/;

my %h2b = qw /0 0000 1 0001 2 0010 3 0011 4 0100 5 0101 6 0110 7 0111
              8 1000 9 1001 A 1010 B 1011 C 1100 D 1101 E 1110 F 1111/;

my %b2h = reverse %h2b;
my $txt;
binmode STDOUT, ':encoding(UTF-8)';


sub my_chr {
  my ($num) = @_;
  if ($num >= 128 and $num <= 255) {
    my $ch = chr($num);
    utf8::upgrade($ch);
    return $ch;
  }
  else {
    return chr($num);
  }
}

if (@ARGV == 0) {
  while (<>) {
    conversion $_;
  }
}
else {
  foreach (@ARGV) {
    conversion $_;
  }
}

sub conversion {
  local ($_) = @_;
  if (/^u\+[0-9a-f]+$/i) {
    ucs4_to_utf8 $_;
  }
  elsif (/^\&\#(\d+);$/) {
    ucs4_to_utf8(sprintf "U+%x", $1);
  }
  elsif (/^[0-9a-f]+$/) {
    utf8_to_ucs4 $_;
  }
  elsif (m{/((?:\\b)?[A-Za-z ]+(?:\\b)?)/}) {
    recherche $1;
  }
  else {
    print STDERR "$_ : inconnu\n";
  }
}

sub recherche {
  my ($re) = @_;
  $txt = do "unicore/Name.pl" unless $txt;
  for (grep { $_ =~ /$re/i } split "\n", $txt) {
    /^([0-9A-F]+)\s+/
      and ucs4_to_utf8(sprintf "U+%s", $1);
  }
}

sub utf8_to_ucs4 {
  local ($_) = @_;

  chomp;
  my $anc = normalise_lg $_, 10;
  $_ = uc $_;
  return unless /^[0-9A-F]+$/;
  s/([0-9A-F])/$h2b{$1}/g;

  if (/^0*(.......)$/) {
    $_ = '0' x 25 . $1;
  }
  elsif (/^0*110(.....)10(......)$/) {
    $_ = "0" x 21 . "$1$2";
  }
  elsif (/^0*1110(....)10(......)10(......)$/) {
    $_ = "0" x 16 . "$1$2$3";
  }
  elsif (/^0*11110(...)10(......)10(......)10(......)$/) {
    $_ = "000$1$2$3$4";
  }
  else {
    print STDERR "$anc : chaîne UTF-8 invalide\n";
    return;
  }

  s/(....)/$b2h{$1}/g;
  my $num = hex($_);
  print "$anc U+$_ &#$num; ", sprintf("C-q %o ", $num), my_chr($num), ' ', charnames::viacode(hex $_), "\n";
}

sub ucs4_to_utf8 {
  local ($_) = @_;
  chomp $_;

  $_ = uc(substr($_, 2));
  my $anc = 'U+' . normalise_lg($_, 8);

  my $num = hex($_);
  if ($num < 0x80) {
    $_ = "000000$_";
  }
  elsif ($num < 0x0800) {
    s/([0-9A-F])/$h2b{$1}/g;
    $_ = normalise_lg($_, 11);
    substr($_, 0, 0) ='110';
    substr($_, 8, 0) = '10';
    s/(....)/$b2h{$1}/g;
    $_ = "0000$_";
  }
  elsif ($num < 0x10000) {
    s/([0-9A-F])/$h2b{$1}/g;
    $_ = normalise_lg($_, 16);
    substr($_,  0, 0) = '1110';
    substr($_,  8, 0) = '10';
    substr($_, 16, 0) = '10';
    s/(....)/$b2h{$1}/g;
    $_ = "00$_";
  }
  else {
    s/([0-9A-F])/$h2b{$1}/g;
    $_ = normalise_lg($_, 21);
    substr($_,  0, 0) = '11110';
    substr($_,  8, 0) = '10';
    substr($_, 16, 0) = '10';
    substr($_, 24, 0) = '10';
    s/(....)/$b2h{$1}/g;
  }
  print '00' . $_, " $anc &#$num; ", sprintf("C-q %o ", $num), my_chr($num), ' ', charnames::viacode($num), "\n";
}

sub normalise_lg {
  my ($str, $lg) = @_;
  if (length($str) < $lg) {
    $str = '0' x ($lg - length($str)) . $_;
  }
  else {
    $str = substr($str, -$lg);
  }
  return $str;
}

=head1 NOM

outilf8 - outil pour les conversions UTF-8 vers Unicode et inversement

=head1 VERSION

Cette documentation décrit C<outilf8> version 0.0.1.

=head1 UTILISATION

  # En mode bref, avec des arguments
  outilf8 u+e9 '&#171;' c2bb

  # En mode long, avec l'entrée standard
  outilf8
  u+e9
  &#171;
  c2bb
  ^D

=head1 ARGUMENTS OBLIGATOIRES

Les arguments sont facultatifs. S'il  n'y a aucun argument en ligne de
commande, l'outil lit l'entrée standard pour en extraire les arguments
à analyser  et à  convertir. S'il  y a au  moins un  argument, l'outil
ignore  son entrée  standard  et  analyse les  arguments  en ligne  de
commande.

Les arguments peuvent prendre ces deux formes :

  u+<nombre hexadécimal>
  &#<nombre décimal>;

Dans  ces  deux  cas,  le  nombre,  décimal  ou  hexadécimal,  est  le
I<codepoint> Unicode. Dans où l'on  fournit un nombre décimal en ligne
de commande, ne pas oublier d'encadrer la chaîne dans des apostrophes,
à cause du rôle spécial  de l'esperluète et du point-virgule en shell.
Bien que l'écriture habituelle des I<codepoints> Unicode se fasse avec
un S<« U »> majuscule et des chiffres hexadécimaux C<« A »> à C<« F »>
majuscules, il est possible de les spécifier en minuscules.

L'argument  peut également  prendre la  forme d'un  nombre hexadécimal
sans  préfixe.    Dans  ce  cas,   il  s'agit  d'une   suite  d'octets
correspondant  à l'écriture  du caractère  en UTF-8.  Comme ci-dessus,
l'utilisation des minuscules est autorisé.

Finalement,   l'argument   peut   être   une  chaîne   de   caractères
alphabétiques et blancs encadrés  par deux slashs. Cela représente une
chaîne de recherche pour fouiller dans la liste des noms normalisés de
caractères.   Cette  chaîne  peut  contenir  la  séquence  C<\b>  pour
représenter une limite de mot. C'est la seule séquence spéciale prévue
dans cette chaîne de recherche. La recherche se fait sans tenir compte
de la distinction minuscules-majuscules.

=head1 OPTIONS

Pour le moment, aucune option.

=head1 DESCRIPTION

Une description  complète de  l'application et de  ses fonctionnalités
Peut comporter des sous-sections (càd =head2, =head3, etc.).

=head1 DIAGNOSTICS

=over 4

=item Chaîne UTF-8 invalide

Un argument hexadécimal sans préfixe C<U+> contient une suite de bits
incompatible avec le codage UTF-8.

=item Inconnu

L'argument ne correspond pas aux quatres schémas connus : C<U+xxxx> ou
C<&#xxxx;> pour  un I<codepoint>  Unicode, un nombre  hexadécimal pour
une  séquence UTF-8  ou une  expression régulière  entre  deux slashs,
cette  expression régulière ne  pouvant contenir  que des  lettres, du
blanc et une balise C<\b> au début ou à la fin ou aux deux extrémités.

=back

=head1 CONFIGURATION ET ENVIRONNEMENT

Néant.

=head1 DÉPENDANCES

Néant.

=head1 INCOMPATIBILITÉS

Aucune incompatibilité identifiée.

=head1 BOGUES ET LIMITES

Pour l'instant, aucun n'a été identifié.

=head1 AUTEUR

Jean Forget, JFORGET (à) cpan.org

=head1 LICENCE ET COPYRIGHT

(C) Jean Forget, 2011, tous droits réservés.

Les termes  de licence  de ce  script sont les  mêmes termes  que pour
Perl : GNU General Public License (GPL) et Artistic License.

