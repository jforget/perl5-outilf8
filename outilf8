#!/usr/bin/perl
# -*- encoding: utf-8 -*-

use strict;
use warnings;
use charnames ':full';
use subs qw/conversion recherche utf8_to_ucs4 ucs4_to_utf8 normalise_lg/;

my %h2b = qw /0 0000 1 0001 2 0010 3 0011 4 0100 5 0101 6 0110 7 0111
              8 1000 9 1001 A 1010 B 1011 C 1100 D 1101 E 1110 F 1111/;

my %b2h = reverse %h2b;
my $txt;

if (@ARGV == 0) {
  while (<>) {
    conversion $_;
  }
}
else {
  foreach (@ARGV) {
    conversion $_;
  }
}

sub conversion {
  local ($_) = @_;
  if (/^u\+[0-9a-z]+$/i) {
    ucs4_to_utf8 $_;
  }
  elsif (/^\&\#(\d+);$/) {
    ucs4_to_utf8(sprintf "U+%x", $1);
  }
  elsif (/^[0-9a-z]+$/) {
    utf8_to_ucs4 $_;
  }
  elsif (m{/((?:\\b)?[A-Za-z ]+(?:\\b)?)/}) {
    recherche $1;
  }
  else {
    print STDERR "$_ : inconnu\n";
  }
}

sub recherche {
  my ($re) = @_;
  $txt = do "unicore/Name.pl" unless $txt;
  for (grep { $_ =~ /$re/i } split "\n", $txt) {
    /^([0-9A-F]+)\s+/
      and ucs4_to_utf8(sprintf "U+%s", $1);
  }
}

sub utf8_to_ucs4 {
  local ($_) = @_;

  chomp;
  my $anc = normalise_lg $_, 10;
  $_ = uc $_;
  return unless /^[0-9A-F]+$/;
  s/([0-9A-F])/$h2b{$1}/g;

  if (/^0*(.......)$/) {
    $_ = '0' x 25 . $1;
  }
  elsif (/^0*110(.....)10(......)$/) {
    $_ = "0" x 21 . "$1$2";
  }
  elsif (/^0*1110(....)10(......)10(......)$/) {
    $_ = "0" x 16 . "$1$2$3";
  }
  elsif (/^0*11110(...)10(......)10(......)10(......)$/) {
    $_ = "000$1$2$3$4";
  }
  else {
    print STDERR "$anc : chaîne UTF-8 invalide\n";
    return;
  }

  s/(....)/$b2h{$1}/g;
  my $num = hex($_);
  print "$anc U+$_ &#$num; ", sprintf("C-q %o ", $num), ' ', charnames::viacode(hex $_), "\n";
}

sub ucs4_to_utf8 {
  local ($_) = @_;
  chomp $_;

  $_ = uc(substr($_, 2));
  my $anc = 'U+' . normalise_lg($_, 8);

  my $num = hex($_);
  if ($num < 0x80) {
    $_ = "000000$_";
  }
  elsif ($num < 0x0800) {
    s/([0-9A-F])/$h2b{$1}/g;
    $_ = normalise_lg($_, 11);
    substr($_, 0, 0) ='110';
    substr($_, 8, 0) = '10';
    s/(....)/$b2h{$1}/g;
    $_ = "0000$_";
  }
  elsif ($num < 0x10000) {
    s/([0-9A-F])/$h2b{$1}/g;
    $_ = normalise_lg($_, 16);
    substr($_,  0, 0) = '1110';
    substr($_,  8, 0) = '10';
    substr($_, 16, 0) = '10';
    s/(....)/$b2h{$1}/g;
    $_ = "00$_";
  }
  else {
    s/([0-9A-F])/$h2b{$1}/g;
    $_ = normalise_lg($_, 21);
    substr($_,  0, 0) = '11110';
    substr($_,  8, 0) = '10';
    substr($_, 16, 0) = '10';
    substr($_, 24, 0) = '10';
    s/(....)/$b2h{$1}/g;
  }
  print '00' . $_, " $anc &#$num; ", sprintf("C-q %o ", $num), charnames::viacode($num), "\n";
}

sub normalise_lg {
  my ($str, $lg) = @_;
  if (length($str) < $lg) {
    $str = '0' x ($lg - length($str)) . $_;
  }
  else {
    $str = substr($str, -$lg);
  }
  return $str;
}

=head1 NOM

outilf8 - outil pour les conversions UTF-8 vers Unicode et inversement

=head1 VERSION

Cette documentation décrit C<outilf8> version 0.0.1.

=head1 UTILISATION

  # En mode bref, avec des arguments
  outilf8 u+e9 '&#171;' c2bb

  # En mode long, avec l'entrée standard
  outilf8
  u+e9
  &#171;
  c2bb
  ^D

=head1 ARGUMENTS OBLIGATOIRES

Les arguments sont facultatifs. S'il  n'y a aucun argument en ligne de
commande, l'outil lit l'entrée standard pour en extraire les arguments
à analyser  et à  convertir. S'il  y a au  moins un  argument, l'outil
ignore  son entrée  standard  et  analyse les  arguments  en ligne  de
commande.

Les arguments peuvent prendre ces deux formes :

  u+I<nombre hexadécimal>
  &#<nombre décimal>

Dans  ces  deux  cas,  le  nombre,  décimal  ou  hexadécimal,  est  le
I<codepoint> Unicode. Dans où l'on  fournit un nombre décimal en ligne
de commande, ne pas oublier d'encadrer la chaîne dans des apostrophes,
à cause du rôle spécial de l'esperluète en shell.

L'argument  peut également  prendre la  forme d'un  nombre hexadécimal
sans   préfixe.  Dans  ce   cas,  il   s'agit  d'une   suite  d'octets
correspondant à l'écriture du caractère en UTF-8.

Finalement,   l'argument   peut   être   une  chaîne   de   caractères
alphabétiques et blancs encadrés  par deux slashs. Cela représente une
chaîne de recherche pour fouiller dans la liste des noms normalisés de
caractères.  Cette  chaîne  peut   contenir  la  séquence  C<\b>  pour
représenter une limite de mot. C'est la seule séquence spéciale prévue
dans cette chaîne de recherche.

=head1 OPTIONS

La liste complète de toutes les options disponibles
lors de l'appel de l'application, avec pour chacune
l'explication de son rôle et les restrictions
et interactions avec les autres paramètres.

Si l'application n'a aucune option,
cette section peut être omise en totalité.

=head1 DESCRIPTION

Une description complète de l'application et de ses fonctionnalités
Peut comporter des sous-sections (càd =head2, =head3, etc.).

=head1 DIAGNOSTICS

La liste de tous les messages d'erreur et d'avertissement que l'application
est susceptible de renvoyer (y compris les erreurs qui « n'arriveront
jamais »), avec une explication détaillée de chaque problème,
la ou les causes probables et quelques suggestions de correction.
Si, lorsque l'application se termine, elle renvoie un code
statut (sous Unix, par exemple), ce paragraphe liste les codes
statuts associés à chaque erreur.

=head1 CONFIGURATION ET ENVIRONNEMENT

Une explication complète du ou des systèmes de configuration de l'application,
avec entre autres le nom et l'emplacement des fichiers de configuration
et le nom des variables d'environnement et des propriétés que l'on
peut positionner. Cela peut inclure la description détaillée
du langage de configuration.

=head1 DÉPENDANCES

=head1 INCOMPATIBILITÉS

=head1 BOGUES ET LIMITES

=head1 AUTEUR

Jean Forget, JFORGET (à) cpan.org

=head1 LICENSE ET COPYRIGHT

Les termes  de licence  de ce  script sont les  mêmes termes  que pour
Perl.
